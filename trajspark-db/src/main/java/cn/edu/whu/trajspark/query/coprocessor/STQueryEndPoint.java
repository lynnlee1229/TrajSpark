package cn.edu.whu.trajspark.query.coprocessor;

import cn.edu.whu.trajspark.base.trajectory.TrajFeatures;
import cn.edu.whu.trajspark.base.trajectory.Trajectory;
import cn.edu.whu.trajspark.coding.XZTCoding;
import cn.edu.whu.trajspark.coding.utils.DateTimeParse;
import cn.edu.whu.trajspark.database.Database;
import cn.edu.whu.trajspark.database.util.TrajectorySerdeUtils;
import cn.edu.whu.trajspark.datatypes.TemporalQueryType;
import cn.edu.whu.trajspark.datatypes.TimeLine;
import cn.edu.whu.trajspark.index.RowKeyRange;
import cn.edu.whu.trajspark.index.time.TimeIndexStrategy;
import cn.edu.whu.trajspark.query.condition.TemporalQueryCondition;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition.QueryRequest;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition.QueryResponse;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition.QueryService;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition.QueryType;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition.Range;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition.TemporalQueryWindow;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition.TemporalQueryWindows;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition.TrajectoryResult;
import com.google.protobuf.ByteString;
import com.google.protobuf.RpcCallback;
import com.google.protobuf.RpcController;
import com.google.protobuf.Service;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.Coprocessor;
import org.apache.hadoop.hbase.CoprocessorEnvironment;
import org.apache.hadoop.hbase.client.Get;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.coprocessor.CoprocessorException;
import org.apache.hadoop.hbase.coprocessor.CoprocessorService;
import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;
import org.apache.hadoop.hbase.filter.MultiRowRangeFilter;
import org.apache.hadoop.hbase.regionserver.InternalScanner;
import org.apache.hadoop.hbase.util.Bytes;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * @author Haocheng Wang Created on 2022/10/27
 */
public class STQueryEndPoint extends QueryService implements Coprocessor, CoprocessorService {

  private final Logger logger = LoggerFactory.getLogger(STQueryEndPoint.class);
  private RegionCoprocessorEnvironment env;

  @Override
  public void query(RpcController controller, QueryRequest request,
      RpcCallback<QueryResponse> done) {

    List<Range> rangeList = request.getRangeList();
    List<TrajectoryResult> trajectoryResults = new ArrayList<>();
    try {
      // 2个scan，第一个不需要粗过滤。
      List<InnerScan> innerScans = getScans(rangeList, request);
      // 扫描, 解析结果
      for (InnerScan innerScan : innerScans) {
        Scan scan = innerScan.scan;
        InternalScanner scanner = env.getRegion().getScanner(scan);
        List<Cell> cells = new ArrayList<>();
        boolean hasMore = scanner.next(cells) || !cells.isEmpty();
        while (hasMore) {
          Result result = Result.create(cells);
          if (!innerScan.needFilter) {
            // 如果当前索引result 的定位到多个indexstrategy，如xz2与xz2+
            // (这种两个空间键都存在的情况是不应该的，但是否需要考虑一个容错机制)，是否考虑增加一个去重操作？
            if (!TrajectorySerdeUtils.isMainIndexed(result)) {
              result = getMainIndexedResult(result);
            }
            TrajectoryResult trajectoryResult = TrajectoryResult.newBuilder()
                .setRowkey(ByteString.copyFrom(result.getRow())).setTrajPointList(
                    ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result,
                        TrajectorySerdeUtils.TRAJ_POINTS_QUALIFIER))).setObjectId(ByteString.copyFrom(
                    TrajectorySerdeUtils.getByteArrayByQualifier(result, TrajectorySerdeUtils.OBJECT_ID_QUALIFIER)))
                .setTid(ByteString.copyFrom(
                    TrajectorySerdeUtils.getByteArrayByQualifier(result, TrajectorySerdeUtils.TRAJECTORY_ID_QUALIFIER)))
                .setStartTime(ByteString.copyFrom(
                    TrajectorySerdeUtils.getByteArrayByQualifier(result, TrajectorySerdeUtils.START_TIME_QUALIFIER)))
                .setEndTime(ByteString.copyFrom(
                    TrajectorySerdeUtils.getByteArrayByQualifier(result, TrajectorySerdeUtils.END_TIME_QUALIFIER)))
                .build();
            trajectoryResults.add(trajectoryResult);
          } else {
            // 使用pos code, mbr等粗过滤
            if (coarseFilter(result, request)) {
              // 使用point list作精过滤
              // TODO: 精过滤考虑放到Client端
              if (!TrajectorySerdeUtils.isMainIndexed(result)) {
                result = getMainIndexedResult(result);
              }
              if (fineFilter(result, request)) {
                TrajectoryResult trajectoryResult = TrajectoryResult.newBuilder()
                    .setRowkey(ByteString.copyFrom(result.getRow())).setTrajPointList(
                        ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result,
                            TrajectorySerdeUtils.TRAJ_POINTS_QUALIFIER))).
                    setObjectId(ByteString.copyFrom(
                        TrajectorySerdeUtils.getByteArrayByQualifier(result, TrajectorySerdeUtils.OBJECT_ID_QUALIFIER)))
                    .setTid(ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result,
                        TrajectorySerdeUtils.TRAJECTORY_ID_QUALIFIER))).
                    setStartTime(ByteString.copyFrom(
                        TrajectorySerdeUtils.getByteArrayByQualifier(result, TrajectorySerdeUtils.START_TIME_QUALIFIER)))
                    .setEndTime(ByteString.copyFrom(
                        TrajectorySerdeUtils.getByteArrayByQualifier(result, TrajectorySerdeUtils.END_TIME_QUALIFIER)))
                    .build();
                trajectoryResults.add(trajectoryResult);
              }
            }
          }
          // 读取下一行
          cells.clear();
          hasMore = scanner.next(cells) || !cells.isEmpty();
        }
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
    QueryResponse response = QueryResponse.newBuilder().addAllList(trajectoryResults).build();
    done.run(response);
  }

  @Override
  public void start(CoprocessorEnvironment env) throws IOException {
    if (env instanceof RegionCoprocessorEnvironment) {
      this.env = (RegionCoprocessorEnvironment) env;
    } else {
      throw new CoprocessorException("Failed to init coprocessor env.");
    }
  }

  /**
   * Get a scan array of size 2 to scan ranges that need / don't need server-side column filter
   * respectively.
   *
   * @return The scan object at offset 0 will read all records that <strong>absolutely</strong> meet
   * the query request, the other object at offset 1 will read all records that <strong>may</strong>
   * meet the query request according to the row key coding strategy.
   * @throws IOException
   */
  private List<InnerScan> getScans(List<Range> rangeList, QueryRequest request) throws IOException {
    List<MultiRowRangeFilter.RowRange> rowRangeListConfirmed = new ArrayList<>(rangeList.size());
    List<MultiRowRangeFilter.RowRange> rowRangeListSuspected = new ArrayList<>(rangeList.size());
    System.out.println("scan");
    for (Range range : rangeList) {
      List<MultiRowRangeFilter.RowRange> listToAdd =
          range.getContained() ? rowRangeListConfirmed : rowRangeListSuspected;
      listToAdd.add(new MultiRowRangeFilter.RowRange(range.getStart().toByteArray(), true,
          range.getEnd().toByteArray(), false));
    }
    List<InnerScan> innerScans = new LinkedList<>();
    if (!rowRangeListConfirmed.isEmpty()) {
      Scan scan0 = getScanWithColumns(request);
      scan0.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.PTR_QUALIFIER);
      scan0.setFilter(new MultiRowRangeFilter(rowRangeListConfirmed));
      innerScans.add(new InnerScan(scan0, false));
    }
    if (!rowRangeListSuspected.isEmpty()) {
      Scan scan1 = getScanWithColumns(request);
      scan1.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.PTR_QUALIFIER);
      scan1.setFilter(new MultiRowRangeFilter(rowRangeListSuspected));
      innerScans.add(new InnerScan(scan1, true));
    }
    return innerScans;
  }

  /**
   * 按需为scan配置查询的列
   *
   * @return
   */
  protected Scan getScanWithColumns(QueryRequest request) {
    Scan scan = new Scan();
    // mbr, signature, point list, ptr
    scan.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.MBR_QUALIFIER);
    scan.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.OBJECT_ID_QUALIFIER);
    scan.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.SIGNATURE_QUALIFIER);
    scan.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.TRAJ_POINTS_QUALIFIER);
    scan.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.PTR_QUALIFIER);
    scan.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.TRAJECTORY_ID_QUALIFIER);
    scan.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.START_TIME_QUALIFIER);
    scan.addColumn(TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.END_TIME_QUALIFIER);
    return scan;
  }

  private Result getMainIndexedResult(Result result) throws IOException {
    return Database.getInstance().getTable(env.getRegionInfo().getTable().getNameAsString())
        .get(new Get(result.getValue(
            TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.PTR_QUALIFIER)));
  }


  /**
   * 基于result内以单独列存储的信息作粗过滤, 例如:mbr, start_time, end_time等.
   *
   * @param result
   * @param queryRequest
   * @return
   */
  protected boolean coarseFilter(Result result, QueryRequest queryRequest) {
    WKTReader wktReader = new WKTReader();
    boolean validate = true;
    if (queryRequest.hasSpatialQueryWindow()) {
      try {
        Geometry queryGeom = wktReader.read(queryRequest.getSpatialQueryWindow().getWkt());
        TrajFeatures trajectoryFeature = TrajectorySerdeUtils.getTrajectoryFeatures(result);
        if (queryRequest.getSpatialQueryType() == QueryType.CONTAIN) {
          validate = queryGeom.contains(trajectoryFeature.getMbr().toPolygon(4326));
        } else {
          validate = queryGeom.intersects(trajectoryFeature.getMbr().toPolygon(4326));
        }
        // TODO : filter with signature.
        if (result.getValue(
            TrajectorySerdeUtils.COLUMN_FAMILY, TrajectorySerdeUtils.SIGNATURE_QUALIFIER) != null) {
          validate = validate;
        }
      } catch (ParseException | IOException e) {
        e.printStackTrace();
      }
    }
    if (queryRequest.hasTemporalQueryWindows() & !queryRequest.hasSpatialQueryWindow()) {
      List<TemporalQueryWindow> temporalQueryWindowList = queryRequest.getTemporalQueryWindows()
          .getTemporalQueryWindowList();
      TemporalQueryCondition temporalQueryCondition = null;
      List<TimeLine> temporalQueryLineList = new ArrayList<>();
      for (TemporalQueryWindow temporalQueryWindow : temporalQueryWindowList) {
        TimeLine timeLine = new TimeLine(DateTimeParse.timeToZonedTime(temporalQueryWindow.getStartMs()),
            DateTimeParse.timeToZonedTime(temporalQueryWindow.getEndMs()));
        temporalQueryLineList.add(timeLine);
      }
      if (queryRequest.getTemporalQueryType() == QueryType.CONTAIN) {
        temporalQueryCondition = new TemporalQueryCondition(temporalQueryLineList,
            TemporalQueryType.CONTAIN);
      } else {
        temporalQueryCondition = new TemporalQueryCondition(temporalQueryLineList,
            TemporalQueryType.INTERSECT);
      }
      TimeIndexStrategy timeIndexStrategy = new TimeIndexStrategy(new XZTCoding());
      List<RowKeyRange> scanRanges = timeIndexStrategy.getScanRanges(temporalQueryCondition, queryRequest.getOid());
      for (RowKeyRange range : scanRanges) {
        int startKey = Bytes.toInt(range.getStartKey().getBytes());
        int endKey = Bytes.toInt(range.getEndKey().getBytes());
        int rowKey = Bytes.toInt(result.getRow());
        if (rowKey >= startKey && rowKey <= endKey) {
          return validate;
        }
      }
      validate = false;
    }
    return validate;
  }

  /**
   * 根据需要配置具体的精过滤条件, 对于最常用的时间\空间条件, 已提供了如下开箱即用的精过滤方法:
   *
   * @see STQueryEndPoint#spatialFineFilter(Result, QueryRequest)
   */
  protected boolean fineFilter(Result result, QueryRequest queryRequest) throws IOException {
    boolean validate = true;
    if (queryRequest.hasSpatialQueryWindow()) {
      validate = spatialFineFilter(result, queryRequest);
    }
    if (queryRequest.hasTemporalQueryWindows()) {
      validate = validate & temporalFineFilter(result, queryRequest);
    }
    return validate;
  }

  /**
   * Fine filter based on trajectory line string.
   *
   * @param result       A main indexed trajectory row.
   * @param queryRequest To get spatial query polygon and spatial query type.
   * @return Whether the result trajectory satisfies queryCondition.
   */
  protected boolean spatialFineFilter(Result result, QueryRequest queryRequest) throws IOException {
    Trajectory trajectory = TrajectorySerdeUtils.getTrajectory(result);
    WKTReader wktReader = new WKTReader();
    try {
      Geometry queryGeom = wktReader.read(queryRequest.getSpatialQueryWindow().getWkt());
      if (queryRequest.getSpatialQueryType() == QueryType.CONTAIN) {
        return queryGeom.contains(trajectory.getLineString());
      }
      return queryGeom.intersects(trajectory.getLineString());
    } catch (ParseException e) {
      e.printStackTrace();
    }
    return false;
  }

  protected boolean temporalFineFilter(Result result, QueryRequest queryRequest)
      throws IOException {
    TimeLine trajectoryTimeLine = TrajectorySerdeUtils.getTrajectoryTimeLine(result);
    long startTime = trajectoryTimeLine.getTimeStart().toEpochSecond();
    long endTime = trajectoryTimeLine.getTimeEnd().toEpochSecond();
    TemporalQueryWindows temporalQueryWindows = queryRequest.getTemporalQueryWindows();
    if (queryRequest.getTemporalQueryType() == QueryType.CONTAIN) {
      for (TemporalQueryWindow temporalQueryWindow : temporalQueryWindows.getTemporalQueryWindowList()) {
        if (temporalQueryWindow.getStartMs() <= startTime
            && endTime <= temporalQueryWindow.getEndMs()) {
          return true;
        }
      }
    } else {
      for (TemporalQueryWindow temporalQueryWindow : temporalQueryWindows.getTemporalQueryWindowList()) {
        if (temporalQueryWindow.getStartMs() <= endTime
            && temporalQueryWindow.getEndMs() >= startTime) {
          return true;
        }
      }
    }
    return false;
  }


  @Override
  public void stop(CoprocessorEnvironment env) {

  }

  @Override
  public Service getService() {
    return this;
  }

  static class InnerScan {

    Scan scan;
    boolean needFilter;

    InnerScan(Scan scan, boolean needFilter) {
      this.scan = scan;
      this.needFilter = needFilter;
    }
  }

  private byte[] getRangeEndAsPrefix(byte[] endPrefix) {
    int len = endPrefix.length;
    byte[] res = new byte[len + 1];
    System.arraycopy(endPrefix, 0, res, 0, len);
    res[len] = (byte) 255;
    return res;
  }
}
