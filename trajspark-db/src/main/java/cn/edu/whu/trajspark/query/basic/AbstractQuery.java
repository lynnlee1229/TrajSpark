package cn.edu.whu.trajspark.query.basic;

import cn.edu.whu.trajspark.base.trajectory.Trajectory;
import cn.edu.whu.trajspark.database.DataSet;
import cn.edu.whu.trajspark.database.meta.IndexMeta;
import cn.edu.whu.trajspark.database.table.IndexTable;
import cn.edu.whu.trajspark.datatypes.ByteArray;
import cn.edu.whu.trajspark.index.RowKeyRange;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition;
import com.google.protobuf.ByteString;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * TODO: 重新整理Query相关的类，仅保留一个BasicQuery类，接收ID、S、T三个维度的查询条件。
 * @author Haocheng Wang
 * Created on 2022/9/28
 */
public abstract class AbstractQuery {

  private static final Logger logger = LoggerFactory.getLogger(AbstractQuery.class);

  DataSet dataSet;
  IndexTable targetIndexTable;

  protected AbstractQuery(DataSet dataSet) throws IOException {
    this.dataSet = dataSet;
  }

  protected AbstractQuery(IndexTable targetIndexTable) throws IOException {
    this.targetIndexTable = targetIndexTable;
  }

  /**
   * 基于查询条件与目标表, 获取要查询的row-key范围.
   * @return
   */
  public abstract List<RowKeyRange> getIndexRanges() throws IOException;

  public IndexTable getTargetIndexTable() {
    return targetIndexTable;
  }

  /**
   * Query <strong>all</strong> ranges that meets query request on target table.
   * @return
   */
  public abstract List<Trajectory> executeQuery() throws IOException;

  /**
   * Query <strong>some</strong> ranges on target table.
   * @return
   */
  public abstract List<Trajectory> executeQuery(List<RowKeyRange> range) throws IOException;

  // 这里面能实现比较复杂的逻辑，比如根据数据的时空分布、主副索引的性能差异、查询条件对不同维度的侧重点，选择恰当的index。
  // 当下是一个最简单的逻辑：找到对应查询适合的索引，从里面选一个主索引，避免多次回表查询。
  public abstract IndexMeta findBestIndex();

  public abstract String getQueryInfo();

  protected void setupTargetIndexTable() throws IOException {
    if (targetIndexTable == null) {
      IndexMeta indexMeta = findBestIndex();
      logger.info("Query [{}] will be executed on table: {}", getQueryInfo(), indexMeta.getIndexTableName());
      targetIndexTable = dataSet.getIndexTable(indexMeta);
    }
  }

  /**
   * 类型转换 + 排序
   */
  protected List<QueryCondition.Range> rowKeyRangeToProtoRange(List<RowKeyRange> rowKeyRanges) {
    List<QueryCondition.Range> ranges = new ArrayList<>();
    for (RowKeyRange rowKeyRange : rowKeyRanges) {
      QueryCondition.Range r = QueryCondition.Range.newBuilder()
          .setStart(ByteString.copyFrom(rowKeyRange.getStartKey().getBytes()))
          .setEnd(ByteString.copyFrom(rowKeyRange.getEndKey().getBytes()))
          .setContained(rowKeyRange.isValidate())
          .build();
      ranges.add(r);
    }

    ranges.sort((o1, o2) -> {
      ByteArray o1Start = new ByteArray(o1.getStart().toByteArray());
      ByteArray o2Start = new ByteArray(o2.getStart().toByteArray());
      ByteArray o1End = new ByteArray(o1.getEnd().toByteArray());
      ByteArray o2End = new ByteArray(o2.getEnd().toByteArray());
      return o1Start.compareTo(o2Start) == 0 ? o1End.compareTo(o2End) : o1Start.compareTo(o2Start);
    });
    return ranges;
  }
}
