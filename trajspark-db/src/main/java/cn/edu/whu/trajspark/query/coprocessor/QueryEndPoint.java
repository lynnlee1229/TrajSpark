package cn.edu.whu.trajspark.query.coprocessor;

import cn.edu.whu.trajspark.core.common.trajectory.TrajFeatures;
import cn.edu.whu.trajspark.core.common.trajectory.Trajectory;
import cn.edu.whu.trajspark.database.Database;
import cn.edu.whu.trajspark.database.util.TrajectorySerdeUtils;
import com.google.protobuf.ByteString;
import com.google.protobuf.RpcCallback;
import com.google.protobuf.RpcController;
import com.google.protobuf.Service;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.Coprocessor;
import org.apache.hadoop.hbase.CoprocessorEnvironment;
import org.apache.hadoop.hbase.client.Get;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.coprocessor.CoprocessorException;
import org.apache.hadoop.hbase.coprocessor.CoprocessorService;
import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;
import org.apache.hadoop.hbase.filter.MultiRowRangeFilter;
import org.apache.hadoop.hbase.regionserver.InternalScanner;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition.*;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import static cn.edu.whu.trajspark.database.util.TrajectorySerdeUtils.*;

/**
 * @author Haocheng Wang
 * Created on 2022/10/27
 */
public class QueryEndPoint extends QueryService implements Coprocessor, CoprocessorService {

  private final Logger logger = LoggerFactory.getLogger(QueryEndPoint.class);
  private RegionCoprocessorEnvironment env;

  @Override
  public void query(RpcController controller, QueryRequest request, RpcCallback<QueryResponse> done) {

    List<Range> rangeList = request.getRangeList();
    List<TrajectoryResult> trajectoryResults = new ArrayList<>();
    try {
      // 2个scan，第一个不需要粗过滤。
      List<InnerScan> innerScans = getScans(rangeList, request);
      // 扫描, 解析结果
      for (InnerScan innerScan : innerScans) {
        Scan scan = innerScan.scan;
        InternalScanner scanner = env.getRegion().getScanner(scan);
        List<Cell> cells = new ArrayList<>();
        boolean hasMore = scanner.next(cells) || !cells.isEmpty();
        while (hasMore) {
          Result result = Result.create(cells);
          if (!innerScan.needFilter) {
            if (!TrajectorySerdeUtils.isMainIndexed(result)) {
              result = getMainIndexedResult(result);
            }
            TrajectoryResult trajectoryResult =
                TrajectoryResult.newBuilder().setRowkey(ByteString.copyFrom(result.getRow()))
                    .setTrajPointList(ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result, TRAJ_POINTS_QUALIFIER)))
                    .setObjectId(ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result, OBJECT_ID_QUALIFIER)))
                    .setTid(ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result, TRAJECTORY_ID_QUALIFIER)))
                    .build();
            trajectoryResults.add(trajectoryResult);
          } else {
            // 使用pos code, mbr等粗过滤
            if (coarseFilter(result, request)) {
              // 使用point list作精过滤
              // TODO: 精过滤考虑放到Client端
              if (!TrajectorySerdeUtils.isMainIndexed(result)) {
                result = getMainIndexedResult(result);
              }
              if (fineFilter(result, request)) {
                TrajectoryResult trajectoryResult =
                    TrajectoryResult.newBuilder().setRowkey(ByteString.copyFrom(result.getRow()))
                        .setTrajPointList(ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result, TRAJ_POINTS_QUALIFIER)))
                        .setObjectId(ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result, OBJECT_ID_QUALIFIER)))
                        .setTid(ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result, TRAJECTORY_ID_QUALIFIER)))
                        .build();
                trajectoryResults.add(trajectoryResult);
              }
            }
          }
          // 读取下一行
          cells.clear();
          hasMore = scanner.next(cells) || !cells.isEmpty();
        }
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
    QueryResponse response = QueryResponse.newBuilder()
        .addAllList(trajectoryResults).build();
    done.run(response);
  }

  @Override
  public void start(CoprocessorEnvironment env) throws IOException {
    if (env instanceof RegionCoprocessorEnvironment) {
      this.env = (RegionCoprocessorEnvironment) env;
    } else {
      throw new CoprocessorException("Failed to init coprocessor env.");
    }
  }

  /**
   * Get a scan array of size 2 to scan ranges that need / don't need server-side column filter respectively.
   * @return The scan object at offset 0 will read all records that <strong>absolutely</strong> meet the query request,
   * the other object at offset 1 will read all records that <strong>may</strong> meet the query request according to the row key coding strategy.
   * @throws IOException
   */
  private List<InnerScan> getScans(List<Range> rangeList, QueryRequest request) throws IOException {
    List<MultiRowRangeFilter.RowRange> rowRangeListConfirmed = new ArrayList<>(rangeList.size());
    List<MultiRowRangeFilter.RowRange> rowRangeListSuspected = new ArrayList<>(rangeList.size());
    for (Range range : rangeList) {
      List<MultiRowRangeFilter.RowRange> listToAdd = range.getContained() ? rowRangeListConfirmed : rowRangeListSuspected;
      listToAdd.add(new MultiRowRangeFilter.RowRange(
          range.getStart().toByteArray(), true,
          getRangeEndAsPrefix(range.getEnd().toByteArray()), false));
    }
    List<InnerScan> innerScans = new LinkedList<>();
    if (!rowRangeListConfirmed.isEmpty()) {
      Scan scan0 = getScanWithColumns(request);
      scan0.addColumn(COLUMN_FAMILY, PTR_QUALIFIER);
      scan0.setFilter(new MultiRowRangeFilter(rowRangeListConfirmed));
      innerScans.add(new InnerScan(scan0, false));
    }
    if (!rowRangeListSuspected.isEmpty()) {
      Scan scan1 = getScanWithColumns(request);
      scan1.addColumn(COLUMN_FAMILY, PTR_QUALIFIER);
      scan1.setFilter(new MultiRowRangeFilter(rowRangeListSuspected));
      innerScans.add(new InnerScan(scan1, true));
    }
    return innerScans;
  }

  /**
   * 按需为scan配置查询的列
   * @return
   */
  protected Scan getScanWithColumns(QueryRequest request) {
    Scan scan = new Scan();
    // mbr, signature, point list, ptr
    scan.addColumn(COLUMN_FAMILY, MBR_QUALIFIER);
    scan.addColumn(COLUMN_FAMILY, OBJECT_ID_QUALIFIER);
    scan.addColumn(COLUMN_FAMILY, SIGNATURE_QUALIFIER);
    scan.addColumn(COLUMN_FAMILY, TRAJ_POINTS_QUALIFIER);
    scan.addColumn(COLUMN_FAMILY, PTR_QUALIFIER);
    scan.addColumn(COLUMN_FAMILY, TRAJECTORY_ID_QUALIFIER);
    return scan;
  }

  private Result getMainIndexedResult(Result result) throws IOException {
    return Database.getInstance().getTable(env.getRegionInfo().getTable().getNameAsString())
        .get(new Get(result.getValue(COLUMN_FAMILY, PTR_QUALIFIER)));
  }


  /**
   * 基于result内以单独列存储的信息作粗过滤, 例如:mbr, start_time, end_time等.
   * @param result
   * @param queryRequest
   * @return
   */
  protected boolean coarseFilter(Result result, QueryRequest queryRequest) {
    WKTReader wktReader = new WKTReader();
    boolean validate = true;
    try {
      Geometry queryGeom = wktReader.read(queryRequest.getSpatialQueryWindow().getWkt());
      TrajFeatures trajectoryFeature = TrajectorySerdeUtils.getTrajectoryFeatures(result);
      if (queryRequest.getSpatialQueryType() == QueryType.CONTAIN) {
        validate &= queryGeom.contains(trajectoryFeature.getMbr().toPolygon(4326));
      } else {
        validate &= queryGeom.intersects(trajectoryFeature.getMbr().toPolygon(4326));
      }
      // TODO : filter with signature.
      if (result.getValue(COLUMN_FAMILY, SIGNATURE_QUALIFIER) != null) {
      }
    } catch (ParseException | IOException e) {
      e.printStackTrace();
    }
    return validate;
  }

  /**
   * 根据需要配置具体的精过滤条件, 对于最常用的时间\空间条件, 已提供了如下开箱即用的精过滤方法:
   *
   * @see QueryEndPoint#spatialFineFilter(Result, QueryRequest)
   */
  protected boolean fineFilter(Result result, QueryRequest queryRequest) throws IOException {
    return spatialFineFilter(result, queryRequest);
  }

  /**
   * Fine filter based on trajectory line string.
   * @param result A main indexed trajectory row.
   * @param queryRequest To get spatial query polygon and spatial query type.
   * @return Whether the result trajectory satisfies queryCondition.
   */
  protected boolean spatialFineFilter(Result result, QueryRequest queryRequest) throws IOException {
    Trajectory trajectory = TrajectorySerdeUtils.getTrajectory(result);
    WKTReader wktReader = new WKTReader();
    try {
      Geometry queryGeom = wktReader.read(queryRequest.getSpatialQueryWindow().getWkt());
      if (queryRequest.getSpatialQueryType() == QueryType.CONTAIN) {
        return queryGeom.contains(trajectory.getLineString());
      }
      return queryGeom.intersects(trajectory.getLineString());
    } catch (ParseException e) {
      e.printStackTrace();
    }
    return false;
  }

  // TODO: 基于时间的精过滤
  protected boolean temporalFineFilter(Result result, QueryRequest queryRequest) throws IOException {
    TrajFeatures trajectoryFeatures = TrajectorySerdeUtils.getTrajectoryFeatures(result);
    return false;
  }


  @Override
  public void stop(CoprocessorEnvironment env) {

  }

  @Override
  public Service getService() {
    return this;
  }

  static class InnerScan {
    Scan scan;
    boolean needFilter;

    public InnerScan(Scan scan, boolean needFilter) {
      this.scan = scan;
      this.needFilter = needFilter;
    }
  }

  private byte[] getRangeEndAsPrefix(byte[] endPrefix) {
    int len = endPrefix.length;
    byte[] res = new byte[len + 1];
    System.arraycopy(endPrefix, 0, res, 0, len);
    res[len] = (byte) 255;
    return res;
  }
}
