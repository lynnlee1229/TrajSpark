package cn.edu.whu.trajspark.database.util;

import cn.edu.whu.trajspark.base.mbr.MinimumBoundingBox;
import cn.edu.whu.trajspark.base.point.TrajPoint;
import cn.edu.whu.trajspark.base.trajectory.TrajFeatures;
import cn.edu.whu.trajspark.base.trajectory.Trajectory;
import cn.edu.whu.trajspark.base.util.SerializerUtils;
import cn.edu.whu.trajspark.database.meta.IndexMeta;
import cn.edu.whu.trajspark.datatypes.TimeLine;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition;
import org.apache.hadoop.hbase.CellUtil;
import org.apache.hadoop.hbase.client.Put;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.util.Bytes;

import java.io.IOException;
import java.time.ZonedDateTime;
import java.util.List;

import static cn.edu.whu.trajspark.base.trajectory.Trajectory.Schema.*;
import static cn.edu.whu.trajspark.constant.DBConstants.INDEX_TABLE_CF;

/**
 * Utils helps serialize/deserialize trajectory objects to/from HBase Put/Result.
 *
 * @author Haocheng Wang
 * Created on 2022/10/24
 */
public class TrajectorySerdeUtils {

  public static final byte[] COLUMN_FAMILY = Bytes.toBytes(INDEX_TABLE_CF);
  public static final byte[] TRAJECTORY_ID_QUALIFIER = Bytes.toBytes(TRAJECTORY_ID);
  public static final byte[] OBJECT_ID_QUALIFIER = Bytes.toBytes(OBJECT_ID);
  public static final byte[] MBR_QUALIFIER = Bytes.toBytes(MBR);
  public static final byte[] START_POINT_QUALIFIER = Bytes.toBytes(START_POSITION);
  public static final byte[] END_POINT_QUALIFIER = Bytes.toBytes(END_POSITION);
  public static final byte[] TRAJ_POINTS_QUALIFIER = Bytes.toBytes(TRAJ_POINTS);
  public static final byte[] SIGNATURE_QUALIFIER = Bytes.toBytes(SIGNATURE);
  public static final byte[] PTR_QUALIFIER = Bytes.toBytes(PTR);


  /**
   * Get an main index, so TRAJ_POINTS is not null, but PTR is null
   */
  public static Put getPutForMainIndex(IndexMeta indexMeta, Trajectory trajectory) throws IOException {
    Put put = new Put(indexMeta.getIndexStrategy().index(trajectory).getBytes());
    addBasicTrajectoryInfos(put, trajectory);
    put.addColumn(COLUMN_FAMILY, OBJECT_ID_QUALIFIER,
        SerializerUtils.serializeObject(trajectory.getObjectID()));
    put.addColumn(COLUMN_FAMILY, TRAJECTORY_ID_QUALIFIER,
        SerializerUtils.serializeObject(trajectory.getTrajectoryID()));
    put.addColumn(COLUMN_FAMILY, TRAJ_POINTS_QUALIFIER,
        SerializerUtils.serializeList(trajectory.getPointList(), TrajPoint.class));
    return put;
  }

  /**
   * Get a secondary index put, so TRAJ_POINTS is null, but PTR points to a main index row key byte array.
   */
  public static Put getPutForSecondaryIndex(IndexMeta indexMeta, Trajectory trajectory, byte[] ptr) throws IOException {
    Put put = new Put(indexMeta.getIndexStrategy().index(trajectory).getBytes());
    addBasicTrajectoryInfos(put, trajectory);
    put.addColumn(COLUMN_FAMILY, PTR_QUALIFIER, ptr);
    return put;
  }

  public static Trajectory getTrajectoryFromPut(Put p) throws IOException {
    byte[] trajPointByteArray = CellUtil.cloneValue(p.get(COLUMN_FAMILY, TRAJ_POINTS_QUALIFIER).get(0));
    byte[] objectID = CellUtil.cloneValue(p.get(COLUMN_FAMILY, OBJECT_ID_QUALIFIER).get(0));
    byte[] tID = CellUtil.cloneValue(p.get(COLUMN_FAMILY, TRAJECTORY_ID_QUALIFIER).get(0));
    List<TrajPoint> trajPointList = SerializerUtils.deserializeList(trajPointByteArray, TrajPoint.class);
    String objectStr = (String) SerializerUtils.deserializeObject(objectID, String.class);
    String tidStr = (String) SerializerUtils.deserializeObject(tID, String.class);
    return new Trajectory(tidStr, objectStr, trajPointList);
  }

  /**
   * 
   * Add basic columns (except for TRAJ_POINTS, PTR, SIGNATURE) into put object
   */
  private static void addBasicTrajectoryInfos(Put put, Trajectory trajectory) throws IOException {
    TrajFeatures trajectoryFeatures = trajectory.getTrajectoryFeatures();
    put.addColumn(COLUMN_FAMILY, MBR_QUALIFIER,
        SerializerUtils.serializeObject(trajectoryFeatures.getMbr()));
    put.addColumn(COLUMN_FAMILY, START_POINT_QUALIFIER,
        SerializerUtils.serializeObject(trajectoryFeatures.getStartPoint()));
    put.addColumn(COLUMN_FAMILY, END_POINT_QUALIFIER,
        SerializerUtils.serializeObject(trajectoryFeatures.getEndPoint()));
  }

  /**
   * 将<b>主索引表</b>中的行转换为轨迹对象
   * @param result 主索引表的行，包含了轨迹的全部信息
   * @return 该行存储的轨迹对象
   */
  public static Trajectory mainRowToTrajectory(Result result) throws IOException {
    Trajectory trajectory = new Trajectory();
    trajectory.setTrajectoryID(
        (String) SerializerUtils.deserializeObject(
            result.getValue(COLUMN_FAMILY, TRAJECTORY_ID_QUALIFIER),
            String.class));
    trajectory.setObjectID(
        (String) SerializerUtils.deserializeObject(
            result.getValue(COLUMN_FAMILY, OBJECT_ID_QUALIFIER),
            String.class));
    trajectory.setPointList(
        SerializerUtils.deserializeList(
        result.getValue(COLUMN_FAMILY, TRAJ_POINTS_QUALIFIER),
        TrajPoint.class));
    return trajectory;
  }

  public static Trajectory protoResultToTrajectory(QueryCondition.TrajectoryResult tr) throws IOException{
    byte[] trajPointByteArray = tr.getTrajPointList().toByteArray();
    byte[] objectID = tr.getObjectId().toByteArray();
    byte[] tID = tr.getTid().toByteArray();
    List<TrajPoint> trajPointList = SerializerUtils.deserializeList(trajPointByteArray, TrajPoint.class);
    String objectStr = (String) SerializerUtils.deserializeObject(objectID, String.class);
    String tidStr = (String) SerializerUtils.deserializeObject(tID, String.class);
    return new Trajectory(tidStr, objectStr, trajPointList);
  }

  /**
   * 直接获取Result对象中的MBR列
   */
  public static MinimumBoundingBox getTrajectoryMBR(Result result) throws IOException {
    return (MinimumBoundingBox) SerializerUtils.deserializeObject(
        result.getValue(COLUMN_FAMILY, MBR_QUALIFIER),
        MinimumBoundingBox.class);
  }

  public static TimeLine getTrajectoryTimeLine(Result result) {
    ZonedDateTime startTime = ((TrajPoint) SerializerUtils.deserializeObject(
        result.getValue(COLUMN_FAMILY, START_POINT_QUALIFIER),
        TrajPoint.class)).getTimestamp();
    ZonedDateTime endTime = ((TrajPoint) SerializerUtils.deserializeObject(
        result.getValue(COLUMN_FAMILY, END_POINT_QUALIFIER),
        TrajPoint.class)).getTimestamp();
    return new TimeLine(startTime, endTime);
  }

  public static byte[] getByteArrayByQualifier(Result result, byte[] qualifier) {
    return result.getValue(COLUMN_FAMILY, qualifier);
  }

  public static boolean isMainIndexed(Result result) {
    return result.getValue(COLUMN_FAMILY, PTR_QUALIFIER) == null;
  }
}
