package cn.edu.whu.trajspark.query.coprocessor;

import cn.edu.whu.trajspark.core.common.trajectory.TrajFeatures;
import cn.edu.whu.trajspark.core.common.trajectory.Trajectory;
import cn.edu.whu.trajspark.database.Database;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.BasicSTQueryCoprocessor.*;
import cn.edu.whu.trajspark.database.util.TrajectorySerdeUtils;
import com.google.protobuf.ByteString;
import com.google.protobuf.RpcCallback;
import com.google.protobuf.RpcController;
import com.google.protobuf.Service;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.Coprocessor;
import org.apache.hadoop.hbase.CoprocessorEnvironment;
import org.apache.hadoop.hbase.client.Get;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.coprocessor.CoprocessorException;
import org.apache.hadoop.hbase.coprocessor.CoprocessorService;
import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;
import org.apache.hadoop.hbase.regionserver.InternalScanner;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static cn.edu.whu.trajspark.database.util.TrajectorySerdeUtils.*;

/**
 * @author Haocheng Wang
 * Created on 2022/10/27
 */
public abstract class AbstractSTQueryEndPoint extends QueryService implements Coprocessor, CoprocessorService {

  private final Logger logger = LoggerFactory.getLogger(AbstractSTQueryEndPoint.class);
  private RegionCoprocessorEnvironment env;

  @Override
  public void query(RpcController controller, QueryRequest request, RpcCallback<QueryResponse> done) {

    List<Range> rangeList = request.getRangeList();
    List<TrajectoryResult> trajectoryResults = new ArrayList<>();
    try {
      for (Range range : rangeList) {
        Scan scan = getScan(range, request);
        // 扫描, 解析结果
        InternalScanner scanner = env.getRegion().getScanner(scan);
        List<Cell> cells = new ArrayList<>();
        boolean hasMore = scanner.next(cells) || !cells.isEmpty();
        while (hasMore) {
          Result result = Result.create(cells);
          // 使用pos code, mbr等过滤
          if (coarseFilter(result, request)) {
            // 使用point list作精过滤
            if (!TrajectorySerdeUtils.isMainIndexed(result)) {
              result = getMainIndexedResult(result);
            }
            if (fineFilter(result, request)) {
              TrajectoryResult trajectoryResult =
                  TrajectoryResult.newBuilder().setRowkey(ByteString.copyFrom(result.getRow()))
                      .setTrajPointList(ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result, TRAJ_POINTS_QUALIFIER)))
                      .setObjectId(ByteString.copyFrom(TrajectorySerdeUtils.getByteArrayByQualifier(result, OBJECT_ID_QUALIFIER)))
                          .build();
              trajectoryResults.add(trajectoryResult);
            }
          }
          // 读取下一行
          cells.clear();
          hasMore = scanner.next(cells) || !cells.isEmpty();
        }
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
    QueryResponse response = QueryResponse.newBuilder()
        .addAllList(trajectoryResults).build();
    done.run(response);
  }

  @Override
  public void start(CoprocessorEnvironment env) throws IOException {
    if (env instanceof RegionCoprocessorEnvironment) {
      this.env = (RegionCoprocessorEnvironment) env;
    } else {
      throw new CoprocessorException("Failed to init coprocessor env.");
    }
  }

  private Scan getScan(Range range, QueryRequest request) {
    Scan scan = getScanWithColumns(request);
    // make sure query on secondary index works.
    scan.addColumn(COLUMN_FAMILY, PTR_QUALIFIER);
    scan.withStartRow(range.getStart().toByteArray(), true);
    scan.withStopRow(range.getEnd().toByteArray(), false);
    return scan;
  }

  /**
   * 按需为scan配置查询的列
   * @return
   */
  protected abstract Scan getScanWithColumns(QueryRequest request);

  private Result getMainIndexedResult(Result result) throws IOException {
    return Database.getInstance().getTable(env.getRegionInfo().getTable().getNameAsString())
        .get(new Get(result.getValue(COLUMN_FAMILY, PTR_QUALIFIER)));
  }


  /**
   * 基于result内以单独列存储的信息作粗过滤, 例如:mbr, start_time, end_time等.
   * @param result
   * @param queryRequest
   * @return
   */
  protected abstract boolean coarseFilter(Result result, QueryRequest queryRequest);

  /**
   * 根据需要配置具体的精过滤条件, 对于最常用的时间\空间条件, 已提供了如下开箱即用的精过滤方法:
   *
   * @see AbstractSTQueryEndPoint#spatialFineFilter(Result, QueryRequest)
   * @see AbstractSTQueryEndPoint#temporalFineFilter(Result, QueryRequest)
   */
  protected abstract boolean fineFilter(Result result, QueryRequest queryRequest) throws IOException;

  /**
   * Fine filter based on trajectory line string.
   * @param result A main indexed trajectory row.
   * @param queryRequest To get spatial query polygon and spatial query type.
   * @return Whether the result trajectory satisfies queryCondition.
   */
  protected boolean spatialFineFilter(Result result, QueryRequest queryRequest) throws IOException {
    Trajectory trajectory = TrajectorySerdeUtils.getTrajectory(result);
    WKTReader wktReader = new WKTReader();
    try {
      Geometry queryGeom = wktReader.read(queryRequest.getSpatialQueryWindow().getWkt());
      if (queryRequest.getSpatialQueryType() == QueryType.CONTAIN) {
        return queryGeom.contains(trajectory.getLineString());
      }
      return queryGeom.intersects(trajectory.getLineString());
    } catch (ParseException e) {
      e.printStackTrace();
    }
    return false;
  }

  // TODO: 基于时间的精过滤
  protected boolean temporalFineFilter(Result result, QueryRequest queryRequest) throws IOException {
    TrajFeatures trajectoryFeatures = TrajectorySerdeUtils.getTrajectoryFeatures(result);
    return false;
  }


  @Override
  public void stop(CoprocessorEnvironment env) {

  }

  @Override
  public Service getService() {
    return this;
  }
}
