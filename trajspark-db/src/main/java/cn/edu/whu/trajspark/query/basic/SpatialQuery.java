package cn.edu.whu.trajspark.query.basic;

import cn.edu.whu.trajspark.base.trajectory.Trajectory;
import cn.edu.whu.trajspark.database.DataSet;
import cn.edu.whu.trajspark.database.meta.IndexMeta;
import cn.edu.whu.trajspark.database.table.IndexTable;
import cn.edu.whu.trajspark.index.IndexType;
import cn.edu.whu.trajspark.index.RowKeyRange;
import cn.edu.whu.trajspark.query.condition.SpatialQueryCondition;
import cn.edu.whu.trajspark.query.coprocessor.STCoprocessorQuery;
import cn.edu.whu.trajspark.query.coprocessor.autogenerated.QueryCondition;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * @author Haocheng Wang
 * Created on 2022/10/27
 */
public class SpatialQuery extends AbstractQuery {

  private static final Logger logger = LoggerFactory.getLogger(SpatialQuery.class);

  SpatialQueryCondition spatialQueryCondition;

  public SpatialQuery(DataSet dataSet, SpatialQueryCondition spatialQueryCondition) throws IOException {
    super(dataSet);
    this.spatialQueryCondition = spatialQueryCondition;
  }

  public SpatialQuery(IndexTable targetIndexTable, SpatialQueryCondition spatialQueryCondition) throws IOException {
    super(targetIndexTable);
    this.spatialQueryCondition = spatialQueryCondition;
  }

  @Override
  public List<RowKeyRange> getIndexRanges() throws IOException {
    setupTargetIndexTable();
    return targetIndexTable.getIndexMeta().getIndexStrategy().getScanRanges(spatialQueryCondition);
  }

  @Override
  public List<Trajectory> executeQuery() throws IOException {
    List<RowKeyRange> rowKeyRanges = getIndexRanges();
    return executeQuery(rowKeyRanges);
  }

  @Override
  public List<Trajectory> executeQuery(List<RowKeyRange> rowKeyRanges) throws IOException {
    setupTargetIndexTable();
    List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rowKeyRanges);
    QueryCondition.QueryRequest spatialQueryRequest = QueryCondition.QueryRequest.newBuilder()
        .setSpatialQueryType(spatialQueryCondition.getQueryType() == SpatialQueryCondition.SpatialQueryType.CONTAIN ? QueryCondition.QueryType.CONTAIN : QueryCondition.QueryType.INTERSECT)
        .setSpatialQueryWindow(QueryCondition.SpatialQueryWindow.newBuilder().setWkt(spatialQueryCondition.getQueryWindowWKT()))
        .addAllRange(ranges).build();
    return STCoprocessorQuery.executeQuery(targetIndexTable, spatialQueryRequest);
  }
  public QueryCondition.QueryRequest getQuery(List<RowKeyRange> rowKeyRanges) throws IOException {
    setupTargetIndexTable();
    List<QueryCondition.Range> ranges = rowKeyRangeToProtoRange(rowKeyRanges);
    QueryCondition.QueryRequest spatialQueryRequest = QueryCondition.QueryRequest.newBuilder()
        .setSpatialQueryType(spatialQueryCondition.getQueryType() == SpatialQueryCondition.SpatialQueryType.CONTAIN ? QueryCondition.QueryType.CONTAIN : QueryCondition.QueryType.INTERSECT)
        .setSpatialQueryWindow(QueryCondition.SpatialQueryWindow.newBuilder().setWkt(spatialQueryCondition.getQueryWindowWKT()))
        .addAllRange(ranges).build();
    return spatialQueryRequest;
  }

  public List<Trajectory> executeQueryScan(IndexTable targetIndexTable, QueryCondition.QueryRequest spatialQueryRequest, int time) throws IOException {
    List<Trajectory> trajectories = null;
    for (int i = 0; i < time; i++) {
      trajectories = STCoprocessorQuery.executeQuery(targetIndexTable,
          spatialQueryRequest);
    }
    return trajectories;
  }

  @Override
  public IndexMeta findBestIndex() {
    Map<IndexType, List<IndexMeta>> map = dataSet.getDataSetMeta().getAvailableIndexes();
    // find a spatial index
    List<IndexMeta> spatialIndexList = null;
    if (map.containsKey(IndexType.XZ2)) {
      spatialIndexList = map.get(IndexType.XZ2);
    } else if (map.containsKey(IndexType.XZ2T)) {
      spatialIndexList = map.get(IndexType.XZ2);
    } else if (map.containsKey(IndexType.XZ2Plus)) {
      spatialIndexList = map.get(IndexType.XZ2Plus);
    }
    if (spatialIndexList != null) {
      return IndexMeta.getBestIndexMeta(spatialIndexList);
    }
    // no spatial index so we will do a full table scan, we select a main index.
    return dataSet.getDataSetMeta().getCoreIndexMeta();
  }

  @Override
  public String getQueryInfo() {
    return spatialQueryCondition.getConditionInfo();
  }


}
